Document Title,Authors,Author Affiliations,Publication Title,Date Added To Xplore,Publication Year,Volume,Issue,Start Page,End Page,Abstract,ISSN,ISBNs,DOI,Funding Information,PDF Link,Author Keywords,IEEE Terms,INSPEC Controlled Terms,INSPEC Non-Controlled Terms,Mesh_Terms,Article Citation Count,Reference Count,License,Online Date,Issue Date,Meeting Date,Publisher,Document Identifier
"Finding robust solutions in requirements models","Gregory Gay; Tim Menzies; Omid Jalali; Gregory Mundy; Beau Gilkerson; Martin Feather; James Kiper","West Virginia University, Morgantown, WV, USA; West Virginia University, Morgantown, WV, USA; West Virginia University, Morgantown, WV, USA; Alderson-Broaddus College, Philippi, WV, USA; West Virginia University, Morgantown, WV, USA; Jet Propulsion Laboratory, California Institute of Technology, Pasadena, CA, USA; Department of Computer Science and Systems Analysis, Miami University, Oxford, OH, USA","Automated Software Engineering","","","","","","","Solutions to non-linear requirements engineering problems may be “brittle”; i.e. small changes may dramatically alter solution effectiveness. Hence, it is not enough to just generate solutions to requirements problems- we must also assess solution robustness. The KEYS2 algorithm can generate decision ordering diagrams. Once generated, these diagrams can assess solution robustness in linear time. In experiments with real-world requirements engineering models, we show that KEYS2 can generate decision ordering diagrams in O(N 2). When assessed in terms of terms of (a) reducing inference times, (b) increasing solution quality, and (c) decreasing the variance of the generated solution, KEYS2 out-performs other search algorithms (simulated annealing, ASTAR, MaxWalkSat).","","","https://doi.org/10.1007/s10515-009-0059-7","","https://link.springer.com/content/pdf/10.1007/s10515-009-0059-7.pdf","Simulated Annealing;Analytic Hierarchy Process;Requirement Engineering;Requirement Model;Binary Decision Diagram","Simulated Annealing;Analytic Hierarchy Process;Requirement Engineering;Requirement Model;Binary Decision Diagram","","","","6","195","","","","","",""
"Automated software license analysis","Timo Tuunanen; Jussi Koskinen; Tommi Kärkkäinen","Department of Mathematical Information Technology, University of Jyväskylä, P.O. Box 35 (Agora), 40014, Jyväskylä, Finland; Department of Computer Science and Information Systems, University of Jyväskylä, P.O. Box 35 (Agora), 40014, Jyväskylä, Finland; Department of Mathematical Information Technology, University of Jyväskylä, P.O. Box 35 (Agora), 40014, Jyväskylä, Finland","Automated Software Engineering","","","","","","","Software license is a legal instrument governing the usage or redistribution of copyright-protected software. License analysis is an elaborate undertaking, especially in case of large software consisting of numerous modules under different licenses. This paper describes an automated approach for supporting software license analysis. The approach is implemented in a reverse engineering tool called ASLA. We provide a detailed description of the architecture and features of the tool. The tool is evaluated on the basis of an analysis of 12 OSS (open source software) packages. The results show that licenses for (on average) 89% of the source code files can be identified by using ASLA and that the efficiency of the automated analysis is (on average) 111 files per second. In a further comparison with two other open source license analyzers—OSLC and FOSSology—ASLA shows a competitive performance. The results validate the general feasibility of the ASLA approach in the context of analyzing non-trivial OSS packages.","","","https://doi.org/10.1007/s10515-009-0054-z","","https://link.springer.com/content/pdf/10.1007/s10515-009-0054-z.pdf","Software licenses;Software reuse;Open source software;Reverse engineering;Program comprehension","Software licenses;Software reuse;Open source software;Reverse engineering;Program comprehension","","","","26","317","","","","","",""
"From UML/SPT models to schedulability analysis: approach and a prototype implementation using ATL","Abdelouahed Gherbi; Ferhat Khendek","Electrical and Computer Engineering Department, Concordia University, 1455 de Maisonneuve Blvd. W., Montreal, H3G 1M8, Canada; Electrical and Computer Engineering Department, Concordia University, 1455 de Maisonneuve Blvd. W., Montreal, H3G 1M8, Canada","Automated Software Engineering","","","","","","","Model Driven Architecture (MDA) is a software development approach promoted by the OMG. MDA is based on two key concepts, models and model transformations. Several kinds of models are generally used throughout the development process to specify a software system and to support its analysis and validation. UML and its extensions, such as the UML profile for real-time systems (UML/SPT), are commonly used to define the structure and the behavior of software systems while other models, such as performance models or schedulability models, are more suitable for performance or schedulability analysis, respectively. In this paper we discuss a model transformation enabling the derivation of schedulability analysis models from UML/SPT models. As a proof of concepts, we present a prototype implementation of this model transformation using ATL. We provide a definition of the source and target metamodels using the metamodel specification language KM3 and we specify the transformation in an ATL module. We discuss the merits and limitations of our approach and of its implementation.","","","https://doi.org/10.1007/s10515-008-0045-5","","https://link.springer.com/content/pdf/10.1007/s10515-008-0045-5.pdf","UML;UML/SPT;MDA;Model transformations;Schedulability analysis;ATL;Real-time","UML;UML/SPT;MDA;Model transformations;Schedulability analysis;ATL;Real-time","","","","3","167","","","","","",""
"A semantic framework for metamodel-based languages","Angelo Gargantini; Elvinia Riccobene; Patrizia Scandurra","Dip. Ing. dell’Informazione e Metodi Matematici, Universitá di Bergamo, V.le Marconi, 5, 24044, Dalmine, Italy; Dip. di Tecnologie dell’Informazione, Universitá di Milano, via Bramante, 65, 26013, Crema, Italy; Dip. Ing. dell’Informazione e Metodi Matematici, Universitá di Bergamo, V.le Marconi, 5, 24044, Dalmine, Italy","Automated Software Engineering","","","","","","","In the model-based development context, metamodel-based languages are increasingly being defined and adopted either for general purposes or for specific domains of interest. However, meta-languages such as the MOF (Meta Object Facility)—combined with the OCL (Object Constraint Language) for expressing constraints—used to specify metamodels focus on structural and static semantics but have no built-in support for specifying behavioral semantics. This paper introduces a formal semantic framework for the definition of the semantics of metamodel-based languages. Using metamodelling principles, we propose several techniques, some based on the translational approach while others based on the weaving approach, all showing how the Abstract State Machine formal method can be integrated with current metamodel engineering environments to endow language metamodels with precise and executable semantics.","","","https://doi.org/10.1007/s10515-009-0053-0","","https://link.springer.com/content/pdf/10.1007/s10515-009-0053-0.pdf","Metamodelling;Model-based development;Model driven engineering;Formal methods;Abstract state machines;Language semantics;Semantic (meta-)hooking;Weaving behaviour","Metamodelling;Model-based development;Model driven engineering;Formal methods;Abstract state machines;Language semantics;Semantic (meta-)hooking;Weaving behaviour","","","","31","275","","","","","",""
"Operational definition and automated inference of test-driven development with Zorro","Hongbing Kou; Philip M. Johnson; Hakan Erdogmus","Collaborative Software Development Laboratory, Department of Information and Computer Sciences, University of Hawaii, Honolulu, HI, 96822, USA; Collaborative Software Development Laboratory, Department of Information and Computer Sciences, University of Hawaii, Honolulu, HI, 96822, USA; Kalemun Research Inc., 4462 Bittersweet Pl., Ottawa, ON, K1V1R9, Canada","Automated Software Engineering","","","","","","","Test-driven development (TDD) is a style of development named for its most visible characteristic: the design and implementation of test cases prior to the implementation of the code required to make them pass. Many claims have been made for TDD: that it can improve implementation as well as design quality, that it can improve productivity, that it results in 100% coverage, and so forth. However, research to validate these claims has yielded mixed and sometimes contradictory results. We believe that at least part of the reason for these results stems from differing interpretations of the TDD development style, along with an inability to determine whether programmers actually follow whatever definition of TDD is in use.","","","https://doi.org/10.1007/s10515-009-0058-8","","https://link.springer.com/content/pdf/10.1007/s10515-009-0058-8.pdf","Test driven development;Hackystat;Process measurement","Test driven development;Hackystat;Process measurement","","","","14","256","","","","","",""
"Estimating the feasibility of transition paths in extended finite state machines","Karnig Derderian; Robert M. Hierons; Mark Harman; Qiang Guo","School of Information Systems, Computing and Mathematics, Brunel University, London, UK; School of Information Systems, Computing and Mathematics, Brunel University, London, UK; Department of Computer Science, King’s College London, London, UK; Department of Computer Science, University of Sheffield, Sheffield, UK","Automated Software Engineering","","","","","","","There has been significant interest in automating testing on the basis of an extended finite state machine (EFSM) model of the required behaviour of the implementation under test (IUT). Many test criteria require that certain parts of the EFSM are executed. For example, we may want to execute every transition of the EFSM. In order to find a test suite (set of input sequences) that achieves this we might first derive a set of paths through the EFSM that satisfy the criterion using, for example, algorithms from graph theory. We then attempt to produce input sequences that trigger these paths. Unfortunately, however, the EFSM might have infeasible paths and the problem of determining whether a path is feasible is generally undecidable. This paper describes an approach in which a fitness function is used to estimate how easy it is to find an input sequence to trigger a given path through an EFSM. Such a fitness function could be used in a search-based approach in which we search for a path with good fitness that achieves a test objective, such as executing a particular transition, and then search for an input sequence that triggers the path. If this second search fails then we search for another path with good fitness and repeat the process. We give a computationally inexpensive approach (fitness function) that estimates the feasibility of a path. In order to evaluate this fitness function we compared the fitness of a path with the ease with which an input sequence can be produced using search to trigger the path and we used random sampling in order to estimate this. The empirical evidence suggests that a reasonably good correlation (0.72 and 0.62) exists between the fitness of a path, produced using the proposed fitness function, and an estimate of the ease with which we can randomly generate an input sequence to trigger the path.","","","https://doi.org/10.1007/s10515-009-0057-9","","https://link.springer.com/content/pdf/10.1007/s10515-009-0057-9.pdf","EFSM;Transition feasibility;State-based testing;Automated test generation","EFSM;Transition feasibility;State-based testing;Automated test generation","","","","21","195","","","","","",""
"Test input reduction for result inspection to facilitate fault localization","Dan Hao; Tao Xie; Lu Zhang; Xiaoyin Wang; Jiasu Sun; Hong Mei","Key Laboratory of High Confidence Software Technologies, Ministry of Education, Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, 100871, People’s Republic of China; Department of Computer Science, North Carolina State University, Raleigh, NC, 27695, USA; Key Laboratory of High Confidence Software Technologies, Ministry of Education, Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, 100871, People’s Republic of China; Key Laboratory of High Confidence Software Technologies, Ministry of Education, Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, 100871, People’s Republic of China; Key Laboratory of High Confidence Software Technologies, Ministry of Education, Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, 100871, People’s Republic of China; Key Laboratory of High Confidence Software Technologies, Ministry of Education, Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, 100871, People’s Republic of China","Automated Software Engineering","","","","","","","Testing-based fault-localization (TBFL) approaches often require the availability of high-statement-coverage test suites that sufficiently exercise the areas around the faults. However, in practice, fault localization often starts with a test suite whose quality may not be sufficient to apply TBFL approaches. Recent capture/replay or traditional test-generation tools can be used to acquire a high-statement-coverage test collection (i.e., test inputs only) without expected outputs. But it is expensive or even infeasible for developers to manually inspect the results of so many test inputs. To enable practical application of TBFL approaches, we propose three strategies to reduce the test inputs in an existing test collection for result inspection. These three strategies are based on the execution traces of test runs using the test inputs. With the three strategies, developers can select only a representative subset of the test inputs for result inspection and fault localization. We implemented and applied the three test-input-reduction strategies to a series of benchmarks: the Siemens programs, DC, and TCC. The experimental results show that our approach can help developers inspect the results of a smaller subset (less than 10%) of test inputs, whose fault-localization effectiveness is close to that of the whole test collection.","","","https://doi.org/10.1007/s10515-009-0056-x","","https://link.springer.com/content/pdf/10.1007/s10515-009-0056-x.pdf","Test suite reduction;Testing;Debugging;Fault localization","Test suite reduction;Testing;Debugging;Fault localization","","","","36","316","","","","","",""
"Trading-off security and performance in barrier slicing for remote software entrusting","Mariano Ceccato; Mila Dalla Preda; Jasvir Nagra; Christian Collberg; Paolo Tonella","Fondazione Bruno Kessler, Trento, Italy; University of Trento, Trento, Italy; University of Trento, Trento, Italy; University of Arizona, Tucson, USA; Fondazione Bruno Kessler, Trento, Italy","Automated Software Engineering","","","","","","","Network applications often require that a trust relationship is established between a trusted host (e.g., the server) and an untrusted host (e.g., the client). The remote entrusting problem is the problem of ensuring the trusted host that whenever a request from an untrusted host is served, the requester is in a genuine state, unaffected by malicious modifications or attacks.","","","https://doi.org/10.1007/s10515-009-0047-y","","https://link.springer.com/content/pdf/10.1007/s10515-009-0047-y.pdf","Program slicing;Security;Source code transformation","Program slicing;Security;Source code transformation","","","","5","102","","","","","",""
"Improving static resolution of dynamic class loading in Java using dynamically gathered environment information","Jason Sawin; Atanas Rountev","The Ohio State University, 395 Dreese Labs, 2015 Neil Ave, Columbus, OH, 43210, USA; The Ohio State University, 395 Dreese Labs, 2015 Neil Ave, Columbus, OH, 43210, USA","Automated Software Engineering","","","","","","","In Java software, one important flexibility mechanism is dynamic class loading. Unfortunately, the vast majority of static analyses for Java treat dynamic class loading either unsoundly or too conservatively. We present a novel semi-static approach for resolving dynamic class loading by combining static string analysis with dynamically gathered information about the execution environment. The insight behind the approach is that dynamic class loading often depends on characteristics of the environment that are encoded in various environment variables. Such variables are not static elements; however, their run-time values typically remain the same across multiple executions of the application. Thus, the string values reported by our technique are tailored to the current installation of the system under analysis. Additionally, we propose extensions of string analysis to increase the number of sites that can be resolved purely statically, and to track the names of environment variables. An experimental evaluation on the Java 1.4 standard libraries shows that a state-of-the-art purely static approach resolves only 28% of non-trivial sites, while our approach resolves 74% of such sites. We also demonstrate how the information gained from resolved dynamic class loading can be used to determine the classes that can potentially be instantiated through the use of reflection. Our extensions of string analysis greatly increase the number of resolvable reflective instantiation sites. This work is a step towards making static analysis tools better equipped to handle the dynamic features of Java.","","","https://doi.org/10.1007/s10515-009-0049-9","","https://link.springer.com/content/pdf/10.1007/s10515-009-0049-9.pdf","Static analysis;String analysis;Dynamic class loading;Reflection","Static analysis;String analysis;Dynamic class loading;Reflection","","","","12","143","","","","","",""
"On temporal path conditions in dependence graphs","Andreas Lochbihler; Gregor Snelting","Lehrstuhl Programmierparadigmen, Universität Karlsruhe (TH), Karlsruhe, Germany; Lehrstuhl Programmierparadigmen, Universität Karlsruhe (TH), Karlsruhe, Germany","Automated Software Engineering","","","","","","","Program dependence graphs are a well-established device to represent possible information flow in a program. Path conditions in dependence graphs have been proposed to express more detailed circumstances of a particular flow; they provide precise necessary conditions for information flow along a path or chop in a dependence graph. Ordinary boolean path conditions, however, cannot express temporal properties, e.g. that for a specific flow it is necessary that some condition holds, and later another specific condition holds.","","","https://doi.org/10.1007/s10515-009-0050-3","","https://link.springer.com/content/pdf/10.1007/s10515-009-0050-3.pdf","Program dependence graph;Path condition;Temporal logic;Security analysis","Program dependence graph;Path condition;Temporal logic;Security analysis","","","","1","93","","","","","",""
"Demand-driven evaluation of collection attributes","Eva Magnusson; Torbjörn Ekman; Görel Hedin","Department of Computer Science, Lund University, Lund, Sweden; Computing Laboratory, Oxford University, Oxford, UK; Department of Computer Science, Lund University, Lund, Sweden","Automated Software Engineering","","","","","","","In order to make attribute grammars useful for complicated analysis tasks, a number of extensions to the original Knuth formalism have been suggested. One such extension is the collection attribute mechanism, which allows the value of an attribute to be defined as a combination of contributions from distant nodes in the abstract syntax tree. Another extension that has proven useful is circular attributes, evaluated using fixed-point iteration. In this paper we show how collection attributes and the combined formalism, circular collection attributes, have been implemented in our declarative meta programming system JastAdd, and how they can be used for a variety of applications including devirtualization analysis, metrics and flow analysis. A number of evaluation algorithms are introduced and compared for applicability and efficiency. The key design criterion for our algorithms is that they work well with demand evaluation, i.e., defined properties are computed only if they are actually needed for a particular program. We show that the best algorithms work well on large practical problems including the analysis of large Java programs.","","","https://doi.org/10.1007/s10515-009-0046-z","","https://link.springer.com/content/pdf/10.1007/s10515-009-0046-z.pdf","Attribute grammars;Collection attributes;Circular attributes;Fixed-point computations;Source code analysis","Attribute grammars;Collection attributes;Circular attributes;Fixed-point computations;Source code analysis","","","","7","121","","","","","",""
"An integrated crosscutting concern migration strategy and its semi-automated application to JHotDraw","Marius Marin; Arie van Deursen; Leon Moonen; Robin van der Rijst","Technology Architecture, Accenture, Gustav Mahlerplein 90, 1082 MA, Amsterdam, The Netherlands; Delft University of Technology, Delft, The Netherlands; Simula Research Laboratory, Lysaker, Norway; Delft University of Technology, Delft, The Netherlands","Automated Software Engineering","","","","","","","In this paper we propose a systematic strategy for migrating crosscutting concerns in existing object-oriented systems to aspect-oriented programming solutions. The proposed strategy consists of four steps: mining, exploration, documentation and refactoring of crosscutting concerns. We discuss in detail a new approach to refactoring to aspect-oriented programming that is fully integrated with our strategy, and apply the whole strategy to an object-oriented system, namely the JHotDraw framework.","","","https://doi.org/10.1007/s10515-009-0051-2","","https://link.springer.com/content/pdf/10.1007/s10515-009-0051-2.pdf","Program analysis;Code refactoring;Cross cutting concerns;Concern modeling;Aspect-oriented programming;Reverse engineering;Software engineering","Program analysis;Code refactoring;Cross cutting concerns;Concern modeling;Aspect-oriented programming;Reverse engineering;Software engineering","","","","9","552","","","","","",""
"Precise slicing of concurrent programs","Dennis Giffhorn; Christian Hammer","Universität Karlsruhe (TH), Karlsruhe, Germany; Universität Karlsruhe (TH), Karlsruhe, Germany","Automated Software Engineering","","","","","","","While there exist efficient algorithms to slice sequential programs precisely, there are only two algorithms for precise slicing of concurrent interprocedural programs with recursive procedures (Krinke in Proc. ESEC/FSE’03, pp. 178–187, 2003; Nanda and Ramesh in ACM Toplas. 28(6):1088–1144, 2006). We present an empirical evaluation of both algorithms for Java. We demonstrate that both algorithms provide the same precision up to the model of concurrency in use and show that the concurrency model has strong impact on slice precision and computation costs. Furthermore, we extend both algorithms to support dynamic thread creation both in loops and recursion—a feature that the original algorithms could not fully handle. The worst case complexity of the algorithms being exponential, we developed several optimizations and compared these with each other and with algorithms that trade precision for speed. Finally, we show that one algorithm may produce incorrect slices and present a remedy.","","","https://doi.org/10.1007/s10515-009-0048-x","","https://link.springer.com/content/pdf/10.1007/s10515-009-0048-x.pdf","Slicing;Program analysis;Concurrency;Threads","Slicing;Program analysis;Concurrency;Threads","","","","13","181","","","","","",""
"Parameter reference immutability: formal definition, inference tool, and comparison","Shay Artzi; Adam Kieżun; Jaime Quinonez; Michael D. Ernst","MIT Computer Science and Artificial Intelligence Laboratory, 32 Vassar st., Cambridge, MA, 02142, USA; MIT Computer Science and Artificial Intelligence Laboratory, 32 Vassar st., Cambridge, MA, 02142, USA; MIT Computer Science and Artificial Intelligence Laboratory, 32 Vassar st., Cambridge, MA, 02142, USA; MIT Computer Science and Artificial Intelligence Laboratory, 32 Vassar st., Cambridge, MA, 02142, USA","Automated Software Engineering","","","","","","","Knowing which method parameters may be mutated during a method’s execution is useful for many software engineering tasks. A parameter reference is immutable if it cannot be used to modify the state of its referent object during the method’s execution. We formally define this notion, in a core object-oriented language. Having the formal definition enables determining correctness and accuracy of tools approximating this definition and unbiased comparison of analyses and tools that approximate similar definitions.","","","https://doi.org/10.1007/s10515-008-0043-7","","https://link.springer.com/content/pdf/10.1007/s10515-008-0043-7.pdf","Readonly;Reference immutability;Definition;Combined analysis","Readonly;Reference immutability;Definition;Combined analysis","","","","7","111","","","","","",""
"Reasoning about programs via operational semantics: requirements for a support system","John R. D. Hughes; Cliff B. Jones","School of Computing Science, Newcastle University, Newcastle, UK; School of Computing Science, Newcastle University, Newcastle, UK","Automated Software Engineering","","","","","","","Reasoning about programs using “axioms” is well established; in this paper we argue that reasoning about a program directly in terms of Structural Operational Semantic (SOS) language descriptions is a viable addition and that this is anyway necessary for the vast majority of languages where there is nothing like a full axiomatic description. Using an SOS description is likely to require detailed proofs whose acceptability to users will depend on suitable support systems. The paper presents a very simple example to illustrate how we can reason about (in fact, develop) a program to prove that it satisfies a specification. The main contribution is to use this trivial example to point out issues in designing an interactive proof system for constructing such proofs.","","","https://doi.org/10.1007/s10515-008-0036-6","","https://link.springer.com/content/pdf/10.1007/s10515-008-0036-6.pdf","Structural operational semantics;Proofs about programs;Tool support","Structural operational semantics;Proofs about programs;Tool support","","","","1","73","","","","","",""
"Automated software engineering: supporting understanding","Michael Jackson","The Open University, Milton Keynes, MK7 6BJ, UK","Automated Software Engineering","","","","","","","The most important role for automation in software engineering is the support of human understanding. Some aspects of understanding and how it can be supported are discussed.","","","https://doi.org/10.1007/s10515-008-0034-8","","https://link.springer.com/content/pdf/10.1007/s10515-008-0034-8.pdf","Complexity;Description;Fragmentation;Manipulation;Automation;Mechanisation","Complexity;Description;Fragmentation;Manipulation;Automation;Mechanisation","","","","7","148","","","","","",""
"What is software?","Leon J. Osterweil","Laboratory for Advanced Software Engineering Research, Computer Science Department, University of Massachusetts, Amherst, MA, 01003, USA","Automated Software Engineering","","","","","","","This paper suggests that there may be other types of software besides computer software. The paper identifies parallels between computer software and such other societal artifacts as laws, processes, recipes, and instructions (e.g. for driving and kitbuilding), and suggests that there are similar parallels in the ways in which these artifacts are built and evolved. The paper suggests that technologies for supporting the automation of computer software development and evolution might facilitate work in these other domains. It also suggests that successful approaches in these other domains could have useful and important application to the domain of computer software. It is further suggested that it might be important for discussions such as these to lead to a deeper understanding of the nature of “software”.","","","https://doi.org/10.1007/s10515-008-0031-y","","https://link.springer.com/content/pdf/10.1007/s10515-008-0031-y.pdf","Software engineering;Software process;Software development","Software engineering;Software process;Software development","","","","3","426","","","","","",""
"Personal reflections on automation, programming culture, and model-based software engineering","Bran Selic","Malina Software Corp., 10 Blueridge Court, Nepean, Ontario, Canada, K2J 2J3","Automated Software Engineering","","","","","","","Model-based software engineering (MBSE) is an approach to software development characterized in part by significantly greater levels of automation when compared to more traditional development methods. Computer-based tools play a fundamental role in a number of key aspects of development, including authoring support (many MBSE languages are predominantly visual), automatic or semi-automatic verification, automated translation of specifications into corresponding programs, and so on.","","","https://doi.org/10.1007/s10515-008-0035-7","","https://link.springer.com/content/pdf/10.1007/s10515-008-0035-7.pdf","Model-driven development;Computer-aided software engineering;Psychology of programming;Usability;Computer automation;Software tools","Model-driven development;Computer-aided software engineering;Psychology of programming;Usability;Computer automation;Software tools","","","","26","369","","","","","",""
"Model driven code checking","Gerard J. Holzmann; Rajeev Joshi; Alex Groce","Laboratory for Reliable Software, Jet Propulsion Laboratory, 4800 Oak Grove Drive, Pasadena, CA, 91109, USA; Laboratory for Reliable Software, Jet Propulsion Laboratory, 4800 Oak Grove Drive, Pasadena, CA, 91109, USA; Laboratory for Reliable Software, Jet Propulsion Laboratory, 4800 Oak Grove Drive, Pasadena, CA, 91109, USA","Automated Software Engineering","","","","","","","Model checkers were originally developed to support the formal verification of high-level design models of distributed system designs. Over the years, they have become unmatched in precision and performance in this domain. Research in model checking has meanwhile moved towards methods that allow us to reason also about implementation level artifacts (e.g., software code) directly, instead of hand-crafted representations of those artifacts. This does not mean that there is no longer a place for the use of high-level models, but it does mean that such models are used in a different way today. In the approach that we describe here, high-level models are used to represent the environment for which the code is to be verified, but not the application itself. The code of the application is now executed as is by the model checker, while using powerful forms of abstraction on-the-fly to build the abstract state space that guides the verification process. This model-driven code checking method allows us to verify implementation level code efficiently for high-level safety and liveness properties. In this paper, we give an overview of the methodology that supports this new paradigm of code verification.","","","https://doi.org/10.1007/s10515-008-0033-9","","https://link.springer.com/content/pdf/10.1007/s10515-008-0033-9.pdf","Software verification;Logic model checking;Spin model checker;Embedded C code","Software verification;Logic model checking;Spin model checker;Embedded C code","","","","21","118","","","","","",""
"A journey to highly dynamic, self-adaptive service-based applications","Elisabetta Di Nitto; Carlo Ghezzi; Andreas Metzger; Mike Papazoglou; Klaus Pohl","Politecnico di Milano, DEI, Piazza Leonardo da Vinci, 32, 20133, Milano, Italy; Politecnico di Milano, DEI, Piazza Leonardo da Vinci, 32, 20133, Milano, Italy; University of Duisburg-Essen, SSE, Schützenbahn 70, 45117, Essen, Germany; Tilburg University, INFOLAB, PO Box 90153, 5000 LE, Tilburg, The Netherlands; University of Duisburg-Essen, SSE, Schützenbahn 70, 45117, Essen, Germany","Automated Software Engineering","","","","","","","Future software systems will operate in a highly dynamic world. Systems will need to operate correctly despite of unespected changes in factors such as environmental conditions, user requirements, technology, legal regulations, and market opportunities. They will have to operate in a constantly evolving environment that includes people, content, electronic devices, and legacy systems. They will thus need the ability to continuously adapt themselves in an automated manner to react to those changes. To realize dynamic, self-adaptive systems, the service concept has emerged as a suitable abstraction mechanism. Together with the concept of the service-oriented architecture (SOA), this led to the development of technologies, standards, and methods to build service-based applications by flexibly aggregating individual services. This article discusses how those concepts came to be by taking two complementary viewpoints. On the one hand, it evaluates the progress in software technologies and methodologies that led to the service concept and SOA. On the other hand, it discusses how the evolution of the requirements, and in particular business goals, influenced the progress towards highly dynamic self-adaptive systems. Finally, based on a discussion of the current state of the art, this article points out the possible future evolution of the field.","","","https://doi.org/10.1007/s10515-008-0032-x","","https://link.springer.com/content/pdf/10.1007/s10515-008-0032-x.pdf","Service-oriented computing;Services;Adaptive systems;Self-adaptation","Service-oriented computing;Services;Adaptive systems;Self-adaptation","","","","156","1372","","","","","",""
"The socio-economics of software architecture","Alistair Sutcliffe","Manchester Business School, University of Manchester, Booth Street, Manchester, M15 6PB, UK","Automated Software Engineering","","","","","","","The paper argues that strategic decisions about software architectures need to be based on a social and economic analysis of which designs are likely to succeed and become accepted by users. Software architecture is increasingly having to take account of customisation, reuse, end-user development and system configuration. The relationship between architecture and end users’ requirements is investigated, to propose a cost-benefit framework to support reasoning about architectural choices from the perspective of end users. The relationships between architectural decisions and non-functional requirements is reviewed, and the impact on architecture is assessed using a case study of developing configurable, semi-intelligent software to support medical researchers in e-science domains.","","","https://doi.org/10.1007/s10515-008-0029-5","","https://link.springer.com/content/pdf/10.1007/s10515-008-0029-5.pdf","End-user development;Requirements;Architecture;Cost-benefit analysis","End-user development;Requirements;Architecture;Cost-benefit analysis","","","","3","169","","","","","",""
"Rethinking software design in participation cultures","Gerhard Fischer","Center for Lifelong Learning and Design, University of Colorado, Boulder, USA","Automated Software Engineering","","","","","","","The research activities in software engineering at the Center for LifeLong Learning & Design (L3D) in the past have been grounded in the basic assumption that important aspects of software engineering are best understood as human-centered design activities. Some of the major objectives were to support designers with domain-oriented design environments, allowing them to interact at the problem domain level and to frame activities and artifacts based on an evolutionary approach.","","","https://doi.org/10.1007/s10515-008-0030-z","","https://link.springer.com/content/pdf/10.1007/s10515-008-0030-z.pdf","Software design;Domain-oriented design environments;Human-problem domain interaction;Meta-design;Distribution and diversity;Networked information economy;Participation cultures","Software design;Domain-oriented design environments;Human-problem domain interaction;Meta-design;Distribution and diversity;Networked information economy;Participation cultures","","","","6","125","","","","","",""
"Scalable satisfiability checking and test data generation from modeling diagrams","Yannis Smaragdakis; Christoph Csallner; Ranjith Subramanian","Computer Science, University of Massachusetts, Amherst, USA; Computer Science and Engineering, University of Texas at Arlington, Arlington, USA; TheFind.com, Mountain View, USA","Automated Software Engineering","","","","","","","We explore the automatic generation of test data that respect constraints expressed in the Object-Role Modeling (ORM) language. ORM is a popular conceptual modeling language, primarily targeting database applications, with significant uses in practice. The general problem of even checking whether an ORM diagram is satisfiable is quite hard: restricted forms are easily NP-hard and the problem is undecidable for some expressive formulations of ORM. Brute-force mapping to input for constraint and SAT solvers does not scale: state-of-the-art solvers fail to find data to satisfy uniqueness and mandatory constraints in realistic time even for small examples. We instead define a restricted subset of ORM that allows efficient reasoning yet contains most constraints overwhelmingly used in practice. We show that the problem of deciding whether these constraints are consistent (i.e., whether we can generate appropriate test data) is solvable in polynomial time, and we produce a highly efficient (interactive speed) checker. Additionally, we analyze over 160 ORM diagrams that capture data models from industrial practice and demonstrate that our subset of ORM is expressive enough to handle their vast majority.","","","https://doi.org/10.1007/s10515-008-0044-6","","https://link.springer.com/content/pdf/10.1007/s10515-008-0044-6.pdf","ORM;Modeling;Testing;Databases;NP-hardness;ORM-;Test data generation","ORM;Modeling;Testing;Databases;NP-hardness;ORM-;Test data generation","","","","7","100","","","","","",""
"Monitoring and diagnosing software requirements","Yiqiao Wang; Sheila A. McIlraith; Yijun Yu; John Mylopoulos","Department of Computer Science, University of Toronto, Toronto, Canada; Department of Computer Science, University of Toronto, Toronto, Canada; Computing Department, Faculty of Maths & Computing, The Open Univ., Walton Hall, Milton Keynes, UK; Department of Computer Science, University of Toronto, Toronto, Canada","Automated Software Engineering","","","","","","","We propose a framework adapted from Artificial Intelligence theories of action and diagnosis for monitoring and diagnosing failures of software requirements. Software requirements are specified using goal models where they are associated with preconditions and postconditions. The monitoring component generates log data that contains the truth values of specified pre/post-conditions, as well as system action executions. Such data can be generated at different levels of granularity, depending on diagnostic feedback. The diagnostic component diagnoses the denial of requirements using the log data, and identifies problematic components. To support diagnostic reasoning, we transform the diagnostic problem into a propositional satisfiability (SAT) problem that can be solved by existing SAT solvers. The framework returns sound and complete diagnoses accounting for observed aberrant system behaviors. Our solution is illustrated with two medium-sized publicly available case studies: a Web-based email client and an ATM simulation. Our experimental results demonstrate the scalability of our approach.","","","https://doi.org/10.1007/s10515-008-0042-8","","https://link.springer.com/content/pdf/10.1007/s10515-008-0042-8.pdf","Requirement monitoring;Diagnostics","Requirement monitoring;Diagnostics","","","","38","311","","","","","",""
"Fast extraction of high-quality framework-specific models from application code","Michał Antkiewicz; Thiago Tonelli Bartolomei; Krzysztof Czarnecki","Generative Software Development Lab, University of Waterloo, 200 University Ave. West, Waterloo, N2L 3G1, ON, Canada; Generative Software Development Lab, University of Waterloo, 200 University Ave. West, Waterloo, N2L 3G1, ON, Canada; Generative Software Development Lab, University of Waterloo, 200 University Ave. West, Waterloo, N2L 3G1, ON, Canada","Automated Software Engineering","","","","","","","Framework-specific models represent the design of application code from the framework viewpoint by showing how framework-provided concepts are instantiated in the code. Retrieving such models quickly and precisely is necessary for practical model-supported software engineering, in which developers use design models for development tasks such as code understanding, verifying framework usage rules, and round-trip engineering. Also, comparing models extracted at different times of the software lifecycle supports software evolution tasks.","","","https://doi.org/10.1007/s10515-008-0040-x","","https://link.springer.com/content/pdf/10.1007/s10515-008-0040-x.pdf","Reverse engineering;Framework-specific models;Framework-specific modeling languages;Static analysis;Object-oriented frameworks;Application programming interface;API","Reverse engineering;Framework-specific models;Framework-specific modeling languages;Static analysis;Object-oriented frameworks;Application programming interface;API","","","","2","119","","","","","",""
"Keyword programming in Java","Greg Little; Robert C. Miller","MIT CSAIL, 32 Vassar Street, Cambridge, MA, 02139, USA; MIT CSAIL, 32 Vassar Street, Cambridge, MA, 02139, USA","Automated Software Engineering","","","","","","","Keyword programming is a novel technique for reducing the need to remember details of programming language syntax and APIs, by translating a small number of unordered keywords provided by the user into a valid expression. In a sense, the keywords act as a query that searches the space of expressions that are valid in the given context. Prior work has demonstrated the feasibility and merit of this approach in limited domains. This paper explores the potential for employing this technique in much larger domains, specifically general-purpose programming languages like Java. We present an algorithm for translating keywords into Java method call expressions. When tested on keywords extracted from existing method calls in Java code, the algorithm can accurately reconstruct over 90% of the original expressions. We tested the algorithm on keywords provided by users in a web-based study. The results suggest that users can obtain correct Java code using keyword queries as accurately as they can write the correct Java code themselves. We implemented the algorithm in an Eclipse plug-in as an extension to the autocomplete mechanism and deployed it in a preliminary field study of several users, with mixed results. One interesting result of this work is that most of the information in Java method call expressions lies in the keywords, and details of punctuation and even parameter ordering can often be inferred automatically.","","","https://doi.org/10.1007/s10515-008-0041-9","","https://link.springer.com/content/pdf/10.1007/s10515-008-0041-9.pdf","Java;Autocomplete;Code assistants","Java;Autocomplete;Code assistants","","","","15","506","","","","","",""
"Requirements model generation to support requirements elicitation: the Secure Tropos experience","Nadzeya Kiyavitskaya; Nicola Zannone","Dipartimento di Ingegneria e Scienza dell’Informazione, Università di Trento, Trento, Italy; Department of Computer Science, University of Toronto, 40 St. George Str., Toronto, Ontario, M5S 2E4, Canada","Automated Software Engineering","","","","","","","In recent years several efforts have been devoted by researchers in the Requirements Engineering community to the development of methodologies for supporting designers during requirements elicitation, modeling, and analysis. However, these methodologies often lack tool support to facilitate their application in practice and encourage companies to adopt them.","","","https://doi.org/10.1007/s10515-008-0028-6","","https://link.springer.com/content/pdf/10.1007/s10515-008-0028-6.pdf","Lightweight text analysis;Model generation","Lightweight text analysis;Model generation","","","","7","222","","","","","",""
"A method and tools for large scale scenarios","Robert J. Hall","AT&T Labs Research, Florham Park, NJ, 07932, USA","Automated Software Engineering","","","","","","","Formal scenarios have many uses in requirements engineering, validation, performance modeling, and test generation. Many tools and methodologies can handle scenarios when the number of steps (interleaved inputs and outputs of the target system) is reasonably small. However, scenario based techniques do not scale well with the number of steps, number of actors, and complexity of behaviors and system interactions to be specified in the scenario. First, it is impractically tedious and error-prone to specify thousands of input steps and corresponding expected outputs. Second, even if one can write down such large scale scenarios, confidence in their correctness is naturally low. Third, complex systems requiring large scale scenarios tend to require many such scenarios to adequately cover the behavior space. This paper describes the motivations for and problems of large scale scenarios, as well as the LSS method, which uses automated and semi-automated techniques in describing, maintaining, communicating, and using large scale scenarios in requirements engineering. The method is illustrated in two widely divergent application domains: military live training instrumentation and electronic mail servers. A case study demonstrates the practical and beneficial use of LSS in architectural modeling of a complex, real-world system design.","","","https://doi.org/10.1007/s10515-008-0026-8","","https://link.springer.com/content/pdf/10.1007/s10515-008-0026-8.pdf","Scenario;Large scale;Requirements engineering;Tools;Automated software engineering","Scenario;Large scale;Requirements engineering;Tools;Automated software engineering","","","","4","139","","","","","",""
"Deriving event-based transition systems from goal-oriented requirements models","Emmanuel Letier; Jeff Kramer; Jeff Magee; Sebastian Uchitel","Department of Computer Science, University College London and London Software Systems, Gower Street, London, WC1E 6BT, UK; Department of Computing, Imperial College London and London Software Systems, 180 Queen’s Gate, London, SW7 2BZ, UK; Department of Computing, Imperial College London and London Software Systems, 180 Queen’s Gate, London, SW7 2BZ, UK; Department of Computing, Imperial College London and London Software Systems, 180 Queen’s Gate, London, SW7 2BZ, UK","Automated Software Engineering","","","","","","","Goal-oriented methods are increasingly popular for elaborating software requirements. They offer systematic support for incrementally building intentional, structural, and operational models of the software and its environment. Event-based transition systems on the other hand are convenient formalisms for reasoning about software behaviour at the architectural level.","","","https://doi.org/10.1007/s10515-008-0027-7","","https://link.springer.com/content/pdf/10.1007/s10515-008-0027-7.pdf","Goal-oriented requirements engineering;Labelled transition systems;Method integration;Requirements animation;Requirements analysis","Goal-oriented requirements engineering;Labelled transition systems;Method integration;Requirements animation;Requirements analysis","","","","45","435","","","","","",""
"On similarity-awareness in testing-based fault localization","Dan Hao; Lu Zhang; Ying Pan; Hong Mei; Jiasu Sun","Key Laboratory of High Confidence Software Technologies, Ministry of Education, Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, 100871, China; Key Laboratory of High Confidence Software Technologies, Ministry of Education, Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, 100871, China; Key Laboratory of High Confidence Software Technologies, Ministry of Education, Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, 100871, China; Key Laboratory of High Confidence Software Technologies, Ministry of Education, Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, 100871, China; Key Laboratory of High Confidence Software Technologies, Ministry of Education, Institute of Software, School of Electronics Engineering and Computer Science, Peking University, Beijing, 100871, China","Automated Software Engineering","","","","","","","In the process of software development and maintenance, software debugging is an inevitable and time-consuming task. To accelerate software debugging, various approaches have been proposed to automate fault localization. Among them, testing-based fault-localization approaches are most promising, which use the execution information of many test cases to localize the faults. However, these existing testing-based fault-localization approaches ignore the similarity between test cases, which may harm the effectiveness of these approaches according to our previous research. Therefore, in this paper we propose a similarity-aware fault-localization approach, which takes each test case as a fuzzy set to deal with the similarity between test cases and calculates statements’ suspicions based on the probability theory. To investigate whether SAFL can address the similarity issue effectively, we manually injected redundant test cases in a test suite and performed an experimental study on the original test suite and the test suite with redundancy, respectively. The experimental results demonstrate that in our experiments SAFL is an effective fault-localization approach, whether there is manually injected redundancy in the test suite. To compare SAFL with most existing testing-based fault-localization approaches, we performed another experimental study on Siemens program suite, which is extensively used in the evaluation of many other testing-based fault-localization approaches. This experimental study confirms the effectiveness of SAFL. Based on the two experimental studies, it seems that in our experiments SAFL cannot only deal with test suites containing much redundancy effectively but also perform effectively for test suites without much redundancy.","","","https://doi.org/10.1007/s10515-008-0025-9","","https://link.springer.com/content/pdf/10.1007/s10515-008-0025-9.pdf","Debugging;Maintenance;Fault localization;Fuzzy set","Debugging;Maintenance;Fault localization;Fuzzy set","","","","24","250","","","","","",""
"A portable compiler-integrated approach to permanent checking","Nic Volanschi","1 rue Michel Jeunet, Poissy, 78300, France","Automated Software Engineering","","","","","","","Program checking is now a mature technology, but is not yet used on a large scale. We identify one cause of this gap in the decoupling of checking tools from the everyday development tools. To radically change the situation, we explore the integration of simple user-defined checks into the core of every development process: the compiler. The checks we implement express constrained reachability queries in the control flow graph taking the form “from x to y avoiding z”, where x, y, and z are native code patterns containing a blend of syntactic, semantic and dataflow information. Compiler integration enables continuous checking throughout development, but also a pervasive propagation of checking technology. This integration poses some interesting challenges, including tight bounds on the acceptable overhead, but in turn opens up new perspectives. Factorizing analyses between checking and compiling improves both the efficiency and the expressiveness of the checks.","","","https://doi.org/10.1007/s10515-007-0022-4","","https://link.springer.com/content/pdf/10.1007/s10515-007-0022-4.pdf","Extensible compilers;User-defined checks","Extensible compilers;User-defined checks","","","","3","133","","","","","",""
"Continuous and automated evolution of architecture-to-implementation traceability links","Leonardo G. P. Murta; André van der Hoek; Cláudia M. L. Werner","COPPE—System Engineering and Computer Science, Federal University of Rio de Janeiro, P.O. Box 68511, Rio de Janeiro, RJ, 21945-970, Brazil; Department of Informatics, University of California at Irvine, 221 ICS2 Building, Irvine, CA, 92697-3440, USA; COPPE—System Engineering and Computer Science, Federal University of Rio de Janeiro, P.O. Box 68511, Rio de Janeiro, RJ, 21945-970, Brazil","Automated Software Engineering","","","","","","","A traditional obstacle in the use of multiple representations is the need to maintain traceability among the representations in the face of evolution. The introduction of software architecture, and architecture-based development, has brought this need to architectural descriptions and corresponding source code. Specifically, the task is to relate versions of architectural elements to versions of source code configuration items, and to update those relations as new versions of the architecture and source code are produced. We present ArchTrace, a new approach that we developed to address this problem. ArchTrace distinguishes itself by continuously updating traceability relations from architectural elements to code elements through a policy-based extensible infrastructure that allows a group of developers to choose a set of traceability management policies that best match their situational needs and/or working styles. We introduce the high-level approach of ArchTrace, discuss its extensible infrastructure, and present our current set of ten pluggable traceability management policies. We conclude with a retrospective analysis of data collected from a twenty month period of development and maintenance of Odyssey, a component-based software development environment comprised of over 50,000 lines of code. This analysis shows that our approach is promising: with respect to the ideal set of traceability links, the policies applied resulted in a precision of 95% and recall of 89%.","","","https://doi.org/10.1007/s10515-007-0020-6","","https://link.springer.com/content/pdf/10.1007/s10515-007-0020-6.pdf","Traceability;Software architecture;Configuration management;Software evolution","Traceability;Software architecture;Configuration management;Software evolution","","","","16","250","","","","","",""
"Differencing and merging of architectural views","Marwan Abi-Antoun; Jonathan Aldrich; Nagi Nahas; Bradley Schmerl; David Garlan","Carnegie Mellon University, Pittsburgh, PA, 15213, USA; Carnegie Mellon University, Pittsburgh, PA, 15213, USA; Carnegie Mellon University, Pittsburgh, PA, 15213, USA; Carnegie Mellon University, Pittsburgh, PA, 15213, USA; Carnegie Mellon University, Pittsburgh, PA, 15213, USA","Automated Software Engineering","","","","","","","Differencing and merging architectural views is an important activity in software engineering. However, existing approaches are still based on restrictive assumptions, such as requiring view elements to have unique identifiers or exactly matching types, which is often not the case in many application domains.","","","https://doi.org/10.1007/s10515-007-0023-3","","https://link.springer.com/content/pdf/10.1007/s10515-007-0023-3.pdf","Tree-to-tree correction;View synchronization;Graph matching","Tree-to-tree correction;View synchronization;Graph matching","","","","14","211","","","","","",""
